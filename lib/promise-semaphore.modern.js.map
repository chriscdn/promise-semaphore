{"version":3,"file":"promise-semaphore.modern.js","sources":["../src/semaphore.ts","../src/group-semaphore.ts"],"sourcesContent":["class SemaphoreItem {\n    private queue: Function[];\n    private maxConcurrent: number;\n\n    /**\n     * The number of locks.\n     */\n    public count: number;\n\n    constructor(maxConcurrent: number) {\n        this.queue = [];\n        this.maxConcurrent = maxConcurrent;\n        this.count = 0;\n    }\n\n    get canAcquire(): boolean {\n        return this.count < this.maxConcurrent;\n    }\n\n    private incrementCount() {\n        this.count++;\n    }\n\n    private decrementCount() {\n        this.count--;\n    }\n\n    acquire(): Promise<void> {\n        if (this.canAcquire) {\n            this.incrementCount();\n            return Promise.resolve();\n        } else {\n            return new Promise((resolve) => this.queue.push(resolve));\n        }\n    }\n\n    release(): void {\n        const resolveFunc = this.queue.shift();\n\n        if (resolveFunc) {\n            // Give the micro task queue a small break instead of calling resolveFunc() directly\n            setTimeout(resolveFunc, 0);\n        } else {\n            this.decrementCount();\n        }\n    }\n}\n\nconst defaultKey = \"_default\";\n\nclass Semaphore {\n    private semaphoreInstances: Record<string | number, SemaphoreItem>;\n    private maxConcurrent: number;\n\n    /**\n     * @param {number} [maxConcurrent] The maximum number of concurrent locks.\n     */\n    constructor(maxConcurrent: number = 1) {\n        this.semaphoreInstances = {};\n        this.maxConcurrent = maxConcurrent;\n    }\n\n    private hasSemaphoreInstance(key: string | number = defaultKey) {\n        return Boolean(this.semaphoreInstances[key]);\n    }\n\n    private getSemaphoreInstance(key: string | number = defaultKey) {\n        if (!this.hasSemaphoreInstance(key)) {\n            this.semaphoreInstances[key] = new SemaphoreItem(\n                this.maxConcurrent,\n            );\n        }\n        return this.semaphoreInstances[key];\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    private tidy(key: string | number = defaultKey): void {\n        if (\n            this.hasSemaphoreInstance(key) &&\n            this.getSemaphoreInstance(key).count === 0\n        ) {\n            delete this.semaphoreInstances[key];\n        }\n    }\n\n    /**\n     * A synchronous function to determine whether a lock can be acquired.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} Returns true if the lock on `key` can be acquired, false\n     * otherwise.\n     */\n    canAcquire(key: string | number = defaultKey): boolean {\n        return !this.hasSemaphoreInstance(key) ||\n            this.getSemaphoreInstance(key).canAcquire;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    acquire(key: string | number = defaultKey) {\n        return this.getSemaphoreInstance(key).acquire();\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    release(key: string | number = defaultKey): void {\n        this.getSemaphoreInstance(key).release();\n        this.tidy(key);\n    }\n\n    /**\n     * The number of active locks.  Will always be less or equal to `max`.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    count(key: string | number = defaultKey): number {\n        if (this.hasSemaphoreInstance(key)) {\n            return this.getSemaphoreInstance(key).count;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} True if the semaphore and key has locks, false otherwise.\n     */\n    hasTasks(key: string | number = defaultKey): boolean {\n        return this.count(key) > 0;\n    }\n\n    /**\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async request<T>(\n        fn: Function,\n        key: string | number = defaultKey,\n    ): Promise<T> {\n        try {\n            await this.acquire(key);\n            return await fn();\n        } finally {\n            this.release(key);\n        }\n    }\n\n    /**\n     * Asynchronously executes `fn` if a lock can be immediately acquired.\n     * Otherwise, returns null.\n     *\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async requestIfAvailable<T>(\n        fn: Function,\n        key: string | number = defaultKey,\n    ): Promise<T | null> {\n        if (this.canAcquire(key)) {\n            return this.request(fn, key);\n        } else {\n            return null;\n        }\n    }\n}\n\nexport { Semaphore };\n","import { Semaphore } from \"./semaphore\";\n\n/**\n * GroupSemaphore is a concurrency control mechanism that manages a shared\n * semaphore for different groups of tasks. Each group is identified by a unique\n * key, and the semaphore ensures only one group can run its tasks concurrently.\n *\n * - acquire(key): Increments the active count for the given group. If it's the\n *   first task for the group (active count is 0), it acquires the global\n *   semaphore, ensuring only one group's tasks can proceed at a time.\n *   Subsequent calls in the group increment the count and are permitted to run.\n * - release(key): Decrements the active count for the group. If the last task\n *   for that group is released, it releases the global semaphore, allowing\n *   other groups to proceed.\n *\n * This ensures that only one group can execute concurrently, but multiple tasks\n * within the same group can run as long as no other tasks from different groups\n * are active.\n */\nclass GroupSemaphore {\n    private _semaphore = new Semaphore();\n    private _activeCounts: Record<string, number> = {};\n    private _groupWaiters: Record<string, Promise<void>> = {};\n\n    async acquire(key: string) {\n        const activeCount = this._activeCounts[key] ?? 0;\n        this._activeCounts[key] = activeCount + 1;\n        const waiter = this._groupWaiters[key] ?? this._semaphore.acquire();\n        this._groupWaiters[key] = waiter;\n        await waiter;\n    }\n\n    release(key: string) {\n        const activeCount = this._activeCounts[key];\n\n        if (activeCount === 1) {\n            this._semaphore.release();\n            delete this._activeCounts[key];\n            delete this._groupWaiters[key];\n        } else {\n            this._activeCounts[key] = activeCount - 1;\n        }\n    }\n}\n\nexport { GroupSemaphore };\n"],"names":["SemaphoreItem","constructor","maxConcurrent","this","queue","count","canAcquire","incrementCount","decrementCount","acquire","Promise","resolve","push","release","resolveFunc","shift","setTimeout","defaultKey","Semaphore","semaphoreInstances","hasSemaphoreInstance","key","Boolean","getSemaphoreInstance","tidy","hasTasks","request","fn","requestIfAvailable","GroupSemaphore","_semaphore","_activeCounts","_groupWaiters","_this$_activeCounts$k","_this$_groupWaiters$k","activeCount","waiter"],"mappings":"AAAA,MAAMA,EASFC,WAAAA,CAAYC,GAAqBC,KARzBC,WAAK,EAAAD,KACLD,mBAAa,EAAAC,KAKdE,WAGH,EAAAF,KAAKC,MAAQ,GACbD,KAAKD,cAAgBA,EACrBC,KAAKE,MAAQ,CACjB,CAEA,cAAIC,GACA,OAAOH,KAAKE,MAAQF,KAAKD,aAC7B,CAEQK,cAAAA,GACJJ,KAAKE,OACT,CAEQG,cAAAA,GACJL,KAAKE,OACT,CAEAI,OAAAA,GACI,OAAIN,KAAKG,YACLH,KAAKI,iBACEG,QAAQC,WAER,IAAID,QAASC,GAAYR,KAAKC,MAAMQ,KAAKD,GAExD,CAEAE,OAAAA,GACI,MAAMC,EAAcX,KAAKC,MAAMW,QAE3BD,EAEAE,WAAWF,EAAa,GAExBX,KAAKK,gBAEb,EAGJ,MAAMS,EAAa,WAEnB,MAAMC,EAOFjB,WAAAA,CAAYC,EAAwB,GAACC,KAN7BgB,wBAAkB,EAAAhB,KAClBD,mBAAa,EAMjBC,KAAKgB,mBAAqB,CAAA,EAC1BhB,KAAKD,cAAgBA,CACzB,CAEQkB,oBAAAA,CAAqBC,EAAuBJ,GAChD,OAAOK,QAAQnB,KAAKgB,mBAAmBE,GAC3C,CAEQE,oBAAAA,CAAqBF,EAAuBJ,GAMhD,OALKd,KAAKiB,qBAAqBC,KAC3BlB,KAAKgB,mBAAmBE,GAAO,IAAIrB,EAC/BG,KAAKD,gBAGFC,KAACgB,mBAAmBE,EACnC,CAKQG,IAAAA,CAAKH,EAAuBJ,GAE5Bd,KAAKiB,qBAAqBC,IACe,IAAzClB,KAAKoB,qBAAqBF,GAAKhB,cAExBF,KAAKgB,mBAAmBE,EAEvC,CASAf,UAAAA,CAAWe,EAAuBJ,GAC9B,OAAQd,KAAKiB,qBAAqBC,IAC9BlB,KAAKoB,qBAAqBF,GAAKf,UACvC,CAKAG,OAAAA,CAAQY,EAAuBJ,GAC3B,OAAWd,KAACoB,qBAAqBF,GAAKZ,SAC1C,CAKAI,OAAAA,CAAQQ,EAAuBJ,GAC3Bd,KAAKoB,qBAAqBF,GAAKR,UAC/BV,KAAKqB,KAAKH,EACd,CAOAhB,KAAAA,CAAMgB,EAAuBJ,GACzB,OAAId,KAAKiB,qBAAqBC,GACnBlB,KAAKoB,qBAAqBF,GAAKhB,MAGzC,CACL,CAMAoB,QAAAA,CAASJ,EAAuBJ,GAC5B,OAAWd,KAACE,MAAMgB,GAAO,CAC7B,CAOA,aAAMK,CACFC,EACAN,EAAuBJ,GAEvB,IAEI,aADUd,KAACM,QAAQY,SACNM,GAChB,CAAA,QACGxB,KAAKU,QAAQQ,EAChB,CACL,CAUA,wBAAMO,CACFD,EACAN,EAAuBJ,GAEvB,OAAId,KAAKG,WAAWe,GACLlB,KAACuB,QAAQC,EAAIN,GAEjB,IAEf,ECtJJ,MAAMQ,EAAc5B,WAAAA,GAAAE,KACR2B,WAAa,IAAIZ,OACjBa,cAAwC,CAAE,OAC1CC,cAA+C,CAAA,CAAE,CAEzD,aAAMvB,CAAQY,GAAW,IAAAY,EAAAC,EACrB,MAAMC,EAAqCF,OAA1BA,EAAG9B,KAAK4B,cAAcV,IAAIY,EAAI,EAC/C9B,KAAK4B,cAAcV,GAAOc,EAAc,EACxC,MAAMC,EAAgC,OAA1BF,EAAG/B,KAAK6B,cAAcX,IAAIa,EAAI/B,KAAK2B,WAAWrB,UAC1DN,KAAK6B,cAAcX,GAAOe,QACpBA,CACV,CAEAvB,OAAAA,CAAQQ,GACJ,MAAMc,EAAchC,KAAK4B,cAAcV,GAEnB,IAAhBc,GACAhC,KAAK2B,WAAWjB,iBACTV,KAAK4B,cAAcV,UACnBlB,KAAK6B,cAAcX,IAE1BlB,KAAK4B,cAAcV,GAAOc,EAAc,CAEhD"}