{"version":3,"file":"promise-semaphore.modern.js","sources":["../src/semaphore.ts","../src/group-semaphore.ts"],"sourcesContent":["const defaultKey = \"_default\";\n\ntype KeyPrimitive = string | number;\n\ntype Key = KeyPrimitive | { key?: KeyPrimitive };\ntype KeyOptions = Key & { priority?: number };\n\nconst _isPrimitiveKey = (item: Key): item is KeyPrimitive =>\n    [\"string\", \"number\"].includes(typeof item);\n\nconst resolveKey = (item: Key): KeyPrimitive =>\n    (_isPrimitiveKey(item) ? item : item.key) ?? defaultKey;\n\nconst resolvePriority = (item: KeyOptions) =>\n    (_isPrimitiveKey(item) ? 0 : item.priority) ?? 0;\n\nclass SemaphoreItem {\n    private queue: Array<{\n        resolve: Function;\n        priority: number;\n    }>;\n    private maxConcurrent: number;\n\n    /**\n     * The number of locks.\n     */\n    public count: number;\n\n    constructor(maxConcurrent: number) {\n        this.queue = [];\n        this.maxConcurrent = maxConcurrent;\n        this.count = 0;\n    }\n\n    get canAcquire(): boolean {\n        return this.count < this.maxConcurrent;\n    }\n\n    private incrementCount() {\n        this.count++;\n    }\n\n    private decrementCount() {\n        this.count--;\n    }\n\n    acquire(priority: number): Promise<void> {\n        if (this.canAcquire) {\n            this.incrementCount();\n            return Promise.resolve();\n        } else {\n            return new Promise((resolve) => {\n                this.queue.push({ resolve, priority });\n                this.queue.sort((a, b) => b.priority - a.priority);\n            });\n        }\n    }\n\n    release(): void {\n        const resolveFunc = this.queue.shift();\n\n        if (resolveFunc) {\n            // Give the micro task queue a small break instead of calling resolveFunc() directly\n            setTimeout(resolveFunc.resolve, 0);\n        } else {\n            this.decrementCount();\n        }\n    }\n}\n\nclass Semaphore {\n    private semaphoreInstances: Record<string | number, SemaphoreItem>;\n    private maxConcurrent: number;\n\n    /**\n     * @param {number} [maxConcurrent] The maximum number of concurrent locks.\n     */\n    constructor(maxConcurrent: number = 1) {\n        this.semaphoreInstances = {};\n        this.maxConcurrent = maxConcurrent;\n\n        if (maxConcurrent < 1) {\n            throw new Error(\"The maxConcurrent must be 1 or greater.\");\n        }\n    }\n\n    private hasSemaphoreInstance(key: KeyPrimitive = defaultKey) {\n        return Boolean(this.semaphoreInstances[key]);\n    }\n\n    private getSemaphoreInstance(key: KeyPrimitive = defaultKey) {\n        if (!this.hasSemaphoreInstance(key)) {\n            this.semaphoreInstances[key] = new SemaphoreItem(\n                this.maxConcurrent,\n            );\n        }\n        return this.semaphoreInstances[key];\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    private tidy(key: KeyPrimitive = defaultKey): void {\n        if (\n            this.hasSemaphoreInstance(key) &&\n            this.getSemaphoreInstance(key).count === 0\n        ) {\n            delete this.semaphoreInstances[key];\n        }\n    }\n\n    /**\n     * A synchronous function to determine whether a lock can be acquired.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} Returns true if the lock on `key` can be acquired, false\n     * otherwise.\n     */\n    canAcquire(key: Key = defaultKey): boolean {\n        const _key = resolveKey(key);\n\n        return !this.hasSemaphoreInstance(_key) ||\n            this.getSemaphoreInstance(_key).canAcquire;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    acquire(key: KeyOptions = defaultKey) {\n        const _key = resolveKey(key);\n        const _priority = resolvePriority(key);\n\n        return this.getSemaphoreInstance(_key).acquire(_priority);\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    release(key: Key = defaultKey): void {\n        const _key = resolveKey(key);\n\n        this.getSemaphoreInstance(_key).release();\n        this.tidy(_key);\n    }\n\n    /**\n     * The number of active locks.  Will always be less or equal to `max`.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    count(key: Key = defaultKey): number {\n        const _key = resolveKey(key);\n\n        return (this.hasSemaphoreInstance(_key))\n            ? this.getSemaphoreInstance(_key).count\n            : 0;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} True if the semaphore and key has locks, false otherwise.\n     */\n    hasTasks(key: Key = defaultKey): boolean {\n        return this.count(key) > 0;\n    }\n\n    /**\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async request<T>(\n        fn: Function,\n        key: KeyOptions = defaultKey,\n    ): Promise<T> {\n        try {\n            await this.acquire(key);\n            return await fn();\n        } finally {\n            this.release(key);\n        }\n    }\n\n    /**\n     * Asynchronously executes `fn` if a lock can be immediately acquired.\n     * Otherwise, returns null.\n     *\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async requestIfAvailable<T>(\n        fn: Function,\n        key: KeyOptions = defaultKey,\n    ): Promise<T | null> {\n        if (this.canAcquire(key)) {\n            return this.request(fn, key);\n        } else {\n            return null;\n        }\n    }\n}\n\nexport { Semaphore };\n","import { Semaphore } from \"./semaphore\";\n\n/**\n * GroupSemaphore manages a shared semaphore for different groups of tasks. Each\n * group is identified by a unique key, and the semaphore ensures only one group\n * can run its tasks concurrently.\n *\n * - acquire(key): Increments the active count for the given group. If it's the\n *   first task for the group (active count is 0), it acquires the global\n *   semaphore, ensuring only one group's tasks can proceed at a time.\n *   Subsequent calls in the group increment the count and are permitted to run.\n * - release(key): Decrements the active count for the group. If the last task\n *   for that group is released, it releases the global semaphore, allowing\n *   other groups to proceed.\n *\n * This ensures that only one group can execute concurrently, but multiple tasks\n * within the same group can run as long as no other tasks from different groups\n * are active.\n */\nclass GroupSemaphore {\n    private _semaphore = new Semaphore();\n    private _activeCounts: Record<string, number> = {};\n    private _groupWaiters: Record<string, Promise<void>> = {};\n\n    async acquire(key: string) {\n        const activeCount = this._activeCounts[key] ?? 0;\n        this._activeCounts[key] = activeCount + 1;\n        const waiter = this._groupWaiters[key] ?? this._semaphore.acquire();\n        this._groupWaiters[key] = waiter;\n        await waiter;\n    }\n\n    release(key: string) {\n        const activeCount = this._activeCounts[key];\n\n        if (activeCount === 1) {\n            this._semaphore.release();\n            delete this._activeCounts[key];\n            delete this._groupWaiters[key];\n        } else {\n            this._activeCounts[key] = activeCount - 1;\n        }\n    }\n}\n\nexport { GroupSemaphore };\n"],"names":["defaultKey","_isPrimitiveKey","item","includes","resolveKey","_ref","key","SemaphoreItem","constructor","maxConcurrent","queue","this","count","canAcquire","incrementCount","decrementCount","acquire","priority","Promise","resolve","push","sort","a","b","release","resolveFunc","shift","setTimeout","Semaphore","semaphoreInstances","Error","hasSemaphoreInstance","Boolean","getSemaphoreInstance","tidy","_key","_priority","_ref2","hasTasks","request","fn","requestIfAvailable","GroupSemaphore","_semaphore","_activeCounts","_groupWaiters","_this$_activeCounts$k","_this$_groupWaiters$k","activeCount","waiter"],"mappings":"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"}