{"version":3,"file":"promise-semaphore.modern.js","sources":["../src/semaphore.ts","../src/group-semaphore.ts"],"sourcesContent":["const defaultKey = \"_default\";\n\ntype KeyPrimitive = string | number;\n\ntype Key = KeyPrimitive | { key?: KeyPrimitive };\ntype KeyOptions = Key & { priority?: number };\n\nconst _isPrimitiveKey = (item: Key): item is KeyPrimitive =>\n    [\"string\", \"number\"].includes(typeof item);\n\nconst resolveKey = (item: Key): KeyPrimitive =>\n    (_isPrimitiveKey(item) ? item : item.key) ?? defaultKey;\n\nconst resolvePriority = (item: KeyOptions) =>\n    (_isPrimitiveKey(item) ? 0 : item.priority) ?? 0;\n\nclass SemaphoreItem {\n    private queue: Array<{\n        resolve: Function;\n        priority: number;\n    }>;\n    private maxConcurrent: number;\n\n    /**\n     * The number of locks.\n     */\n    public count: number;\n\n    constructor(maxConcurrent: number) {\n        this.queue = [];\n        this.maxConcurrent = maxConcurrent;\n        this.count = 0;\n    }\n\n    get canAcquire(): boolean {\n        return this.count < this.maxConcurrent;\n    }\n\n    private incrementCount() {\n        this.count++;\n    }\n\n    private decrementCount() {\n        this.count--;\n    }\n\n    acquire(priority: number): Promise<void> {\n        if (this.canAcquire) {\n            this.incrementCount();\n            return Promise.resolve();\n        } else {\n            return new Promise((resolve) => {\n                this.queue.push({ resolve, priority });\n                this.queue.sort((a, b) => b.priority - a.priority);\n            });\n        }\n    }\n\n    release(): void {\n        const resolveFunc = this.queue.shift();\n\n        if (resolveFunc) {\n            // Give the micro task queue a small break instead of calling resolveFunc() directly\n            setTimeout(resolveFunc.resolve, 0);\n        } else {\n            this.decrementCount();\n        }\n    }\n}\n\nclass Semaphore {\n    private semaphoreInstances: Record<string | number, SemaphoreItem>;\n    private maxConcurrent: number;\n\n    /**\n     * @param {number} [maxConcurrent] The maximum number of concurrent locks.\n     */\n    constructor(maxConcurrent: number = 1) {\n        this.semaphoreInstances = {};\n        this.maxConcurrent = maxConcurrent;\n    }\n\n    private hasSemaphoreInstance(key: KeyPrimitive = defaultKey) {\n        return Boolean(this.semaphoreInstances[key]);\n    }\n\n    private getSemaphoreInstance(key: KeyPrimitive = defaultKey) {\n        if (!this.hasSemaphoreInstance(key)) {\n            this.semaphoreInstances[key] = new SemaphoreItem(\n                this.maxConcurrent,\n            );\n        }\n        return this.semaphoreInstances[key];\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    private tidy(key: KeyPrimitive = defaultKey): void {\n        if (\n            this.hasSemaphoreInstance(key) &&\n            this.getSemaphoreInstance(key).count === 0\n        ) {\n            delete this.semaphoreInstances[key];\n        }\n    }\n\n    /**\n     * A synchronous function to determine whether a lock can be acquired.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} Returns true if the lock on `key` can be acquired, false\n     * otherwise.\n     */\n    canAcquire(key: Key = defaultKey): boolean {\n        const _key = resolveKey(key);\n\n        return !this.hasSemaphoreInstance(_key) ||\n            this.getSemaphoreInstance(_key).canAcquire;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    acquire(key: KeyOptions = defaultKey) {\n        const _key = resolveKey(key);\n        const _priority = resolvePriority(key);\n\n        return this.getSemaphoreInstance(_key).acquire(_priority);\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    release(key: Key = defaultKey): void {\n        const _key = resolveKey(key);\n\n        this.getSemaphoreInstance(_key).release();\n        this.tidy(_key);\n    }\n\n    /**\n     * The number of active locks.  Will always be less or equal to `max`.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    count(key: Key = defaultKey): number {\n        const _key = resolveKey(key);\n\n        return (this.hasSemaphoreInstance(_key))\n            ? this.getSemaphoreInstance(_key).count\n            : 0;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} True if the semaphore and key has locks, false otherwise.\n     */\n    hasTasks(key: Key = defaultKey): boolean {\n        return this.count(key) > 0;\n    }\n\n    /**\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async request<T>(\n        fn: Function,\n        key: KeyOptions = defaultKey,\n    ): Promise<T> {\n        try {\n            await this.acquire(key);\n            return await fn();\n        } finally {\n            this.release(key);\n        }\n    }\n\n    /**\n     * Asynchronously executes `fn` if a lock can be immediately acquired.\n     * Otherwise, returns null.\n     *\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async requestIfAvailable<T>(\n        fn: Function,\n        key: KeyOptions = defaultKey,\n    ): Promise<T | null> {\n        if (this.canAcquire(key)) {\n            return this.request(fn, key);\n        } else {\n            return null;\n        }\n    }\n}\n\nexport { Semaphore };\n","import { Semaphore } from \"./semaphore\";\n\n/**\n * GroupSemaphore manages a shared semaphore for different groups of tasks. Each\n * group is identified by a unique key, and the semaphore ensures only one group\n * can run its tasks concurrently.\n *\n * - acquire(key): Increments the active count for the given group. If it's the\n *   first task for the group (active count is 0), it acquires the global\n *   semaphore, ensuring only one group's tasks can proceed at a time.\n *   Subsequent calls in the group increment the count and are permitted to run.\n * - release(key): Decrements the active count for the group. If the last task\n *   for that group is released, it releases the global semaphore, allowing\n *   other groups to proceed.\n *\n * This ensures that only one group can execute concurrently, but multiple tasks\n * within the same group can run as long as no other tasks from different groups\n * are active.\n */\nclass GroupSemaphore {\n    private _semaphore = new Semaphore();\n    private _activeCounts: Record<string, number> = {};\n    private _groupWaiters: Record<string, Promise<void>> = {};\n\n    async acquire(key: string) {\n        const activeCount = this._activeCounts[key] ?? 0;\n        this._activeCounts[key] = activeCount + 1;\n        const waiter = this._groupWaiters[key] ?? this._semaphore.acquire();\n        this._groupWaiters[key] = waiter;\n        await waiter;\n    }\n\n    release(key: string) {\n        const activeCount = this._activeCounts[key];\n\n        if (activeCount === 1) {\n            this._semaphore.release();\n            delete this._activeCounts[key];\n            delete this._groupWaiters[key];\n        } else {\n            this._activeCounts[key] = activeCount - 1;\n        }\n    }\n}\n\nexport { GroupSemaphore };\n"],"names":["defaultKey","_isPrimitiveKey","item","includes","resolveKey","_ref","key","SemaphoreItem","constructor","maxConcurrent","this","queue","count","canAcquire","incrementCount","decrementCount","acquire","priority","Promise","resolve","push","sort","a","b","release","resolveFunc","shift","setTimeout","Semaphore","semaphoreInstances","hasSemaphoreInstance","Boolean","getSemaphoreInstance","tidy","_key","_priority","_ref2","hasTasks","request","fn","requestIfAvailable","GroupSemaphore","_semaphore","_activeCounts","_groupWaiters","_this$_activeCounts$k","_this$_groupWaiters$k","activeCount","waiter"],"mappings":"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"}