{"version":3,"file":"promise-semaphore.modern.js","sources":["../src/index.ts"],"sourcesContent":["class SemaphoreItem {\n  private queue: Array<Function>;\n  private waitQueue: Array<Function>;\n  private maxConcurrent: number;\n\n  /**\n   * The number of locks.\n   */\n  public count: number;\n\n  constructor(maxConcurrent: number) {\n    this.queue = [];\n    this.waitQueue = [];\n    this.maxConcurrent = maxConcurrent;\n    this.count = 0;\n  }\n\n  get canAcquire(): boolean {\n    return this.count < this.maxConcurrent;\n  }\n\n  private incrementCount() {\n    this.count++;\n  }\n\n  private decrementCount() {\n    this.count--;\n\n    if (this.count === 0) {\n      this.waitQueue.forEach((resolve) => resolve());\n      this.waitQueue = [];\n    }\n  }\n\n  acquire(): Promise<void> {\n    if (this.canAcquire) {\n      this.incrementCount();\n      return Promise.resolve();\n    } else {\n      return new Promise((resolve) => this.queue.push(resolve));\n    }\n  }\n\n  release(): void {\n    const resolveFunc = this.queue.shift();\n\n    if (resolveFunc) {\n      // Give the micro task queue a small break instead of calling resolveFunc() directly\n      setTimeout(resolveFunc, 0);\n    } else {\n      this.decrementCount();\n    }\n  }\n\n  wait(): Promise<void> {\n    return new Promise((resolve) => this.waitQueue.push(resolve));\n  }\n}\n\nconst defaultKey = \"_default\";\n\nclass Semaphore {\n  private semaphoreInstances: Record<string | number, SemaphoreItem>;\n  private maxConcurrent: number;\n\n  /**\n   * @param {number} [maxConcurrent] The maximum number of concurrent locks.\n   */\n  constructor(maxConcurrent: number = 1) {\n    this.semaphoreInstances = {};\n    this.maxConcurrent = maxConcurrent;\n  }\n\n  private hasSemaphoreInstance(key: string | number = defaultKey) {\n    return Boolean(this.semaphoreInstances[key]);\n  }\n\n  private getSemaphoreInstance(key: string | number = defaultKey) {\n    if (!this.hasSemaphoreInstance(key)) {\n      this.semaphoreInstances[key] = new SemaphoreItem(this.maxConcurrent);\n    }\n    return this.semaphoreInstances[key];\n  }\n\n  /**\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  private tidy(key: string | number = defaultKey): void {\n    if (\n      this.hasSemaphoreInstance(key) &&\n      this.getSemaphoreInstance(key).count === 0\n    ) {\n      delete this.semaphoreInstances[key];\n    }\n  }\n\n  /**\n   * A synchronous function to determine whether a lock can be acquired.\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {boolean} Returns true if the lock on `key` can be acquired, false\n   * otherwise.\n   */\n  canAcquire(key: string | number = defaultKey): boolean {\n    return this.getSemaphoreInstance(key).canAcquire;\n  }\n\n  /**\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  acquire(key: string | number = defaultKey) {\n    return this.getSemaphoreInstance(key).acquire();\n  }\n\n  /**\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  release(key: string | number = defaultKey): void {\n    this.getSemaphoreInstance(key).release();\n    this.tidy(key);\n  }\n\n  /**\n   * The number of active locks.  Will always be less or equal to `max`.\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  count(key: string | number = defaultKey): number {\n    if (this.hasSemaphoreInstance(key)) {\n      return this.getSemaphoreInstance(key).count;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {boolean} True if the semaphore and key has locks, false otherwise.\n   */\n  hasTasks(key: string | number = defaultKey): boolean {\n    return this.count(key) > 0;\n  }\n\n  /**\n   * @param {Function<T>} fn The function to execute.\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {Promise<T>}\n   */\n  async request<T>(\n    fn: Function,\n    key: string | number = defaultKey,\n  ): Promise<T> {\n    try {\n      await this.acquire(key);\n      return await fn();\n    } finally {\n      this.release(key);\n    }\n  }\n\n  /**\n   * Asynchronously executes `fn` if a lock can be immediately acquired.\n   * Otherwise, returns null.\n   *\n   * @param {Function<T>} fn The function to execute.\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {Promise<T>}\n   */\n  async requestIfAvailable<T>(\n    fn: Function,\n    key: string | number = defaultKey,\n  ): Promise<T | null> {\n    if (this.canAcquire(key)) {\n      return this.request(fn, key);\n    } else {\n      return null;\n    }\n  }\n\n  async wait(key: string | number = defaultKey) {\n    if (this.hasTasks(key)) {\n      return this.getSemaphoreInstance(key).wait();\n    } else {\n      return Promise.resolve();\n    }\n  }\n}\n\nexport default Semaphore;\n"],"names":["SemaphoreItem","constructor","maxConcurrent","this","queue","waitQueue","count","canAcquire","incrementCount","decrementCount","forEach","resolve","acquire","Promise","push","release","resolveFunc","shift","setTimeout","wait","defaultKey","Semaphore","semaphoreInstances","hasSemaphoreInstance","key","Boolean","getSemaphoreInstance","tidy","hasTasks","request","fn","requestIfAvailable"],"mappings":"AAAA,MAAMA,EAUJC,WAAAA,CAAYC,GAAqBC,KATzBC,WAAK,EAAAD,KACLE,eAAS,EAAAF,KACTD,mBAKDI,EAAAA,KAAAA,WAGL,EAAAH,KAAKC,MAAQ,GACbD,KAAKE,UAAY,GACjBF,KAAKD,cAAgBA,EACrBC,KAAKG,MAAQ,CACf,CAEA,cAAIC,GACF,YAAYD,MAAQH,KAAKD,aAC3B,CAEQM,cAAAA,GACNL,KAAKG,OACP,CAEQG,cAAAA,GACNN,KAAKG,QAEc,IAAfH,KAAKG,QACPH,KAAKE,UAAUK,QAASC,GAAYA,KACpCR,KAAKE,UAAY,GAErB,CAEAO,OAAAA,GACE,OAAIT,KAAKI,YACPJ,KAAKK,iBACEK,QAAQF,WAEJ,IAAAE,QAASF,GAAYR,KAAKC,MAAMU,KAAKH,GAEpD,CAEAI,OAAAA,GACE,MAAMC,EAAcb,KAAKC,MAAMa,QAE3BD,EAEFE,WAAWF,EAAa,GAExBb,KAAKM,gBAET,CAEAU,IAAAA,GACE,OAAW,IAAAN,QAASF,GAAYR,KAAKE,UAAUS,KAAKH,GACtD,EAGF,MAAMS,EAAa,WAEnB,MAAMC,EAOJpB,WAAAA,CAAYC,EAAwB,GAN5BoB,KAAAA,wBACApB,EAAAA,KAAAA,qBAMNC,KAAKmB,mBAAqB,GAC1BnB,KAAKD,cAAgBA,CACvB,CAEQqB,oBAAAA,CAAqBC,EAAuBJ,GAClD,OAAOK,QAAQtB,KAAKmB,mBAAmBE,GACzC,CAEQE,oBAAAA,CAAqBF,EAAuBJ,GAIlD,OAHKjB,KAAKoB,qBAAqBC,KAC7BrB,KAAKmB,mBAAmBE,GAAO,IAAIxB,EAAcG,KAAKD,gBAE7CC,KAACmB,mBAAmBE,EACjC,CAKQG,IAAAA,CAAKH,EAAuBJ,GAEhCjB,KAAKoB,qBAAqBC,IACe,IAAzCrB,KAAKuB,qBAAqBF,GAAKlB,cAEpBH,KAACmB,mBAAmBE,EAEnC,CASAjB,UAAAA,CAAWiB,EAAuBJ,GAChC,OAAWjB,KAACuB,qBAAqBF,GAAKjB,UACxC,CAKAK,OAAAA,CAAQY,EAAuBJ,GAC7B,OAAWjB,KAACuB,qBAAqBF,GAAKZ,SACxC,CAKAG,OAAAA,CAAQS,EAAuBJ,GAC7BjB,KAAKuB,qBAAqBF,GAAKT,UAC/BZ,KAAKwB,KAAKH,EACZ,CAOAlB,KAAAA,CAAMkB,EAAuBJ,GAC3B,OAAIjB,KAAKoB,qBAAqBC,GACrBrB,KAAKuB,qBAAqBF,GAAKlB,MAGvC,CACH,CAMAsB,QAAAA,CAASJ,EAAuBJ,GAC9B,OAAOjB,KAAKG,MAAMkB,GAAO,CAC3B,CAOA,aAAMK,CACJC,EACAN,EAAuBJ,GAEvB,IAEE,aADMjB,KAAKS,QAAQY,SACNM,GACd,CAAA,QACC3B,KAAKY,QAAQS,EACd,CACH,CAUA,wBAAMO,CACJD,EACAN,EAAuBJ,GAEvB,OAAIjB,KAAKI,WAAWiB,GACPrB,KAAC0B,QAAQC,EAAIN,GAEjB,IAEX,CAEA,UAAML,CAAKK,EAAuBJ,GAChC,OAAIjB,KAAKyB,SAASJ,GACLrB,KAACuB,qBAAqBF,GAAKL,OAE/BN,QAAQF,SAEnB"}