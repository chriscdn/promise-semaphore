{"version":3,"file":"promise-semaphore.cjs","sources":["../src/index.ts"],"sourcesContent":["class SemaphoreItem {\n  private queue: Array<Function>;\n  private waitQueue: Array<Function>;\n  private maxConcurrent: number;\n\n  /**\n   * The number of locks.\n   */\n  public count: number;\n\n  constructor(maxConcurrent: number) {\n    this.queue = [];\n    this.waitQueue = [];\n    this.maxConcurrent = maxConcurrent;\n    this.count = 0;\n  }\n\n  get canAcquire(): boolean {\n    return this.count < this.maxConcurrent;\n  }\n\n  private incrementCount() {\n    this.count++;\n  }\n\n  private decrementCount() {\n    this.count--;\n\n    if (this.count === 0) {\n      this.waitQueue.forEach((resolve) => resolve());\n      this.waitQueue = [];\n    }\n  }\n\n  acquire(): Promise<void> {\n    if (this.canAcquire) {\n      this.incrementCount();\n      return Promise.resolve();\n    } else {\n      return new Promise((resolve) => this.queue.push(resolve));\n    }\n  }\n\n  release(): void {\n    const resolveFunc = this.queue.shift();\n\n    if (resolveFunc) {\n      // Give the micro task queue a small break instead of calling resolveFunc() directly\n      setTimeout(resolveFunc, 0);\n    } else {\n      this.decrementCount();\n    }\n  }\n\n  wait(): Promise<void> {\n    return new Promise((resolve) => this.waitQueue.push(resolve));\n  }\n}\n\nconst defaultKey = \"_default\";\n\nclass Semaphore {\n  private semaphoreInstances: Record<string | number, SemaphoreItem>;\n  private maxConcurrent: number;\n\n  /**\n   * @param {number} [maxConcurrent] The maximum number of concurrent locks.\n   */\n  constructor(maxConcurrent: number = 1) {\n    this.semaphoreInstances = {};\n    this.maxConcurrent = maxConcurrent;\n  }\n\n  private hasSemaphoreInstance(key: string | number = defaultKey) {\n    return Boolean(this.semaphoreInstances[key]);\n  }\n\n  private getSemaphoreInstance(key: string | number = defaultKey) {\n    if (!this.hasSemaphoreInstance(key)) {\n      this.semaphoreInstances[key] = new SemaphoreItem(this.maxConcurrent);\n    }\n    return this.semaphoreInstances[key];\n  }\n\n  /**\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  private tidy(key: string | number = defaultKey): void {\n    if (\n      this.hasSemaphoreInstance(key) &&\n      this.getSemaphoreInstance(key).count === 0\n    ) {\n      delete this.semaphoreInstances[key];\n    }\n  }\n\n  /**\n   * A synchronous function to determine whether a lock can be acquired.\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {boolean} Returns true if the lock on `key` can be acquired, false\n   * otherwise.\n   */\n  canAcquire(key: string | number = defaultKey): boolean {\n    return this.getSemaphoreInstance(key).canAcquire;\n  }\n\n  /**\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  acquire(key: string | number = defaultKey) {\n    return this.getSemaphoreInstance(key).acquire();\n  }\n\n  /**\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  release(key: string | number = defaultKey): void {\n    this.getSemaphoreInstance(key).release();\n    this.tidy(key);\n  }\n\n  /**\n   * The number of active locks.  Will always be less or equal to `max`.\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  count(key: string | number = defaultKey): number {\n    if (this.hasSemaphoreInstance(key)) {\n      return this.getSemaphoreInstance(key).count;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {boolean} True if the semaphore and key has locks, false otherwise.\n   */\n  hasTasks(key: string | number = defaultKey): boolean {\n    return this.count(key) > 0;\n  }\n\n  /**\n   * @param {Function<T>} fn The function to execute.\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {Promise<T>}\n   */\n  async request<T>(\n    fn: Function,\n    key: string | number = defaultKey,\n  ): Promise<T> {\n    try {\n      await this.acquire(key);\n      return await fn();\n    } finally {\n      this.release(key);\n    }\n  }\n\n  /**\n   * Asynchronously executes `fn` if a lock can be immediately acquired.\n   * Otherwise, returns null.\n   *\n   * @param {Function<T>} fn The function to execute.\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {Promise<T>}\n   */\n  async requestIfAvailable<T>(\n    fn: Function,\n    key: string | number = defaultKey,\n  ): Promise<T | null> {\n    if (this.canAcquire(key)) {\n      return this.request(fn, key);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Wait until the count on `key` is 0 and then resolve.\n   *\n   * @param key\n   * @returns\n   */\n  async wait(key: string | number = defaultKey) {\n    if (this.hasTasks(key)) {\n      return this.getSemaphoreInstance(key).wait();\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  // globalCount() {\n  //   return Object.values(this.semaphoreInstances).reduce(\n  //     (a, instance) => a + instance.count,\n  //     0,\n  //   );\n  // }\n}\n\nexport default Semaphore;\nexport { Semaphore };\n"],"names":["SemaphoreItem","maxConcurrent","queue","waitQueue","count","this","_proto","prototype","incrementCount","decrementCount","forEach","resolve","acquire","_this","canAcquire","Promise","push","release","resolveFunc","shift","setTimeout","wait","_this2","key","get","defaultKey","Semaphore","semaphoreInstances","_proto2","hasSemaphoreInstance","Boolean","getSemaphoreInstance","tidy","hasTasks","request","fn","_this3","then","_finallyRethrows","_wasThrown","_result","e","reject","requestIfAvailable"],"mappings":"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"}