{"version":3,"file":"promise-semaphore.cjs","sources":["../src/semaphore.ts","../src/group-semaphore.ts"],"sourcesContent":["class SemaphoreItem {\n    private queue: Function[];\n    private maxConcurrent: number;\n\n    /**\n     * The number of locks.\n     */\n    public count: number;\n\n    constructor(maxConcurrent: number) {\n        this.queue = [];\n        this.maxConcurrent = maxConcurrent;\n        this.count = 0;\n    }\n\n    get canAcquire(): boolean {\n        return this.count < this.maxConcurrent;\n    }\n\n    private incrementCount() {\n        this.count++;\n    }\n\n    private decrementCount() {\n        this.count--;\n    }\n\n    acquire(): Promise<void> {\n        if (this.canAcquire) {\n            this.incrementCount();\n            return Promise.resolve();\n        } else {\n            return new Promise((resolve) => this.queue.push(resolve));\n        }\n    }\n\n    release(): void {\n        const resolveFunc = this.queue.shift();\n\n        if (resolveFunc) {\n            // Give the micro task queue a small break instead of calling resolveFunc() directly\n            setTimeout(resolveFunc, 0);\n        } else {\n            this.decrementCount();\n        }\n    }\n}\n\nconst defaultKey = \"_default\";\n\nclass Semaphore {\n    private semaphoreInstances: Record<string | number, SemaphoreItem>;\n    private maxConcurrent: number;\n\n    /**\n     * @param {number} [maxConcurrent] The maximum number of concurrent locks.\n     */\n    constructor(maxConcurrent: number = 1) {\n        this.semaphoreInstances = {};\n        this.maxConcurrent = maxConcurrent;\n    }\n\n    private hasSemaphoreInstance(key: string | number = defaultKey) {\n        return Boolean(this.semaphoreInstances[key]);\n    }\n\n    private getSemaphoreInstance(key: string | number = defaultKey) {\n        if (!this.hasSemaphoreInstance(key)) {\n            this.semaphoreInstances[key] = new SemaphoreItem(\n                this.maxConcurrent,\n            );\n        }\n        return this.semaphoreInstances[key];\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    private tidy(key: string | number = defaultKey): void {\n        if (\n            this.hasSemaphoreInstance(key) &&\n            this.getSemaphoreInstance(key).count === 0\n        ) {\n            delete this.semaphoreInstances[key];\n        }\n    }\n\n    /**\n     * A synchronous function to determine whether a lock can be acquired.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} Returns true if the lock on `key` can be acquired, false\n     * otherwise.\n     */\n    canAcquire(key: string | number = defaultKey): boolean {\n        return !this.hasSemaphoreInstance(key) ||\n            this.getSemaphoreInstance(key).canAcquire;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    acquire(key: string | number = defaultKey) {\n        return this.getSemaphoreInstance(key).acquire();\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    release(key: string | number = defaultKey): void {\n        this.getSemaphoreInstance(key).release();\n        this.tidy(key);\n    }\n\n    /**\n     * The number of active locks.  Will always be less or equal to `max`.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    count(key: string | number = defaultKey): number {\n        if (this.hasSemaphoreInstance(key)) {\n            return this.getSemaphoreInstance(key).count;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} True if the semaphore and key has locks, false otherwise.\n     */\n    hasTasks(key: string | number = defaultKey): boolean {\n        return this.count(key) > 0;\n    }\n\n    /**\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async request<T>(\n        fn: Function,\n        key: string | number = defaultKey,\n    ): Promise<T> {\n        try {\n            await this.acquire(key);\n            return await fn();\n        } finally {\n            this.release(key);\n        }\n    }\n\n    /**\n     * Asynchronously executes `fn` if a lock can be immediately acquired.\n     * Otherwise, returns null.\n     *\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async requestIfAvailable<T>(\n        fn: Function,\n        key: string | number = defaultKey,\n    ): Promise<T | null> {\n        if (this.canAcquire(key)) {\n            return this.request(fn, key);\n        } else {\n            return null;\n        }\n    }\n}\n\nexport { Semaphore };\n","import { Semaphore } from \"./semaphore\";\n\n/**\n * GroupSemaphore is a concurrency control mechanism that manages a shared\n * semaphore for different groups of tasks. Each group is identified by a unique\n * key, and the semaphore ensures only one group can run its tasks concurrently.\n *\n * - acquire(key): Increments the active count for the given group. If it's the\n *   first task for the group (active count is 0), it acquires the global\n *   semaphore, ensuring only one group's tasks can proceed at a time.\n *   Subsequent calls in the group increment the count and are permitted to run.\n * - release(key): Decrements the active count for the group. If the last task\n *   for that group is released, it releases the global semaphore, allowing\n *   other groups to proceed.\n *\n * This ensures that only one group can execute concurrently, but multiple tasks\n * within the same group can run as long as no other tasks from different groups\n * are active.\n */\nclass GroupSemaphore {\n    private _semaphore = new Semaphore();\n    private _activeCounts: Record<string, number> = {};\n    private _groupWaiters: Record<string, Promise<void>> = {};\n\n    async acquire(key: string) {\n        const activeCount = this._activeCounts[key] ?? 0;\n        this._activeCounts[key] = activeCount + 1;\n        const waiter = this._groupWaiters[key] ?? this._semaphore.acquire();\n        this._groupWaiters[key] = waiter;\n        await waiter;\n    }\n\n    release(key: string) {\n        const activeCount = this._activeCounts[key];\n\n        if (activeCount === 1) {\n            this._semaphore.release();\n            delete this._activeCounts[key];\n            delete this._groupWaiters[key];\n        } else {\n            this._activeCounts[key] = activeCount - 1;\n        }\n    }\n}\n\nexport { GroupSemaphore };\n"],"names":["SemaphoreItem","maxConcurrent","queue","this","count","_proto","prototype","incrementCount","decrementCount","acquire","_this","canAcquire","Promise","resolve","push","release","resolveFunc","shift","setTimeout","key","get","defaultKey","Semaphore","semaphoreInstances","_proto2","hasSemaphoreInstance","Boolean","getSemaphoreInstance","tidy","hasTasks","request","fn","_this2","then","_finallyRethrows","_wasThrown","_result","e","reject","requestIfAvailable","GroupSemaphore","_semaphore","_activeCounts","_groupWaiters","_this$_activeCounts$k","_this$_groupWaiters$k","activeCount","waiter"],"mappings":"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"}