{"version":3,"file":"promise-semaphore.cjs","sources":["../src/semaphore.ts","../src/group-semaphore.ts"],"sourcesContent":["const defaultKey = \"_default\";\n\ntype KeyPrimitive = string | number;\n\ntype Key = KeyPrimitive | { key?: KeyPrimitive };\ntype KeyOptions = Key & { priority?: number };\n\nconst _isPrimitiveKey = (item: Key): item is KeyPrimitive =>\n    [\"string\", \"number\"].includes(typeof item);\n\nconst resolveKey = (item: Key): KeyPrimitive =>\n    (_isPrimitiveKey(item) ? item : item.key) ?? defaultKey;\n\nconst resolvePriority = (item: KeyOptions) =>\n    (_isPrimitiveKey(item) ? 0 : item.priority) ?? 0;\n\nclass SemaphoreItem {\n    private queue: Array<{\n        resolve: Function;\n        priority: number;\n    }>;\n    private maxConcurrent: number;\n\n    /**\n     * The number of locks.\n     */\n    public count: number;\n\n    constructor(maxConcurrent: number) {\n        this.queue = [];\n        this.maxConcurrent = maxConcurrent;\n        this.count = 0;\n    }\n\n    get canAcquire(): boolean {\n        return this.count < this.maxConcurrent;\n    }\n\n    private incrementCount() {\n        this.count++;\n    }\n\n    private decrementCount() {\n        this.count--;\n    }\n\n    acquire(priority: number): Promise<void> {\n        if (this.canAcquire) {\n            this.incrementCount();\n            return Promise.resolve();\n        } else {\n            return new Promise((resolve) => {\n                this.queue.push({ resolve, priority });\n                this.queue.sort((a, b) => b.priority - a.priority);\n            });\n        }\n    }\n\n    release(): void {\n        const resolveFunc = this.queue.shift();\n\n        if (resolveFunc) {\n            // Give the micro task queue a small break instead of calling resolveFunc() directly\n            setTimeout(resolveFunc.resolve, 0);\n        } else {\n            this.decrementCount();\n        }\n    }\n}\n\nclass Semaphore {\n    private semaphoreInstances: Record<string | number, SemaphoreItem>;\n    private maxConcurrent: number;\n\n    /**\n     * @param {number} [maxConcurrent] The maximum number of concurrent locks.\n     */\n    constructor(maxConcurrent: number = 1) {\n        this.semaphoreInstances = {};\n        this.maxConcurrent = maxConcurrent;\n    }\n\n    private hasSemaphoreInstance(key: KeyPrimitive = defaultKey) {\n        return Boolean(this.semaphoreInstances[key]);\n    }\n\n    private getSemaphoreInstance(key: KeyPrimitive = defaultKey) {\n        if (!this.hasSemaphoreInstance(key)) {\n            this.semaphoreInstances[key] = new SemaphoreItem(\n                this.maxConcurrent,\n            );\n        }\n        return this.semaphoreInstances[key];\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    private tidy(key: KeyPrimitive = defaultKey): void {\n        if (\n            this.hasSemaphoreInstance(key) &&\n            this.getSemaphoreInstance(key).count === 0\n        ) {\n            delete this.semaphoreInstances[key];\n        }\n    }\n\n    /**\n     * A synchronous function to determine whether a lock can be acquired.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} Returns true if the lock on `key` can be acquired, false\n     * otherwise.\n     */\n    canAcquire(key: Key = defaultKey): boolean {\n        const _key = resolveKey(key);\n\n        return !this.hasSemaphoreInstance(_key) ||\n            this.getSemaphoreInstance(_key).canAcquire;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    acquire(key: KeyOptions = defaultKey) {\n        const _key = resolveKey(key);\n        const _priority = resolvePriority(key);\n\n        return this.getSemaphoreInstance(_key).acquire(_priority);\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    release(key: Key = defaultKey): void {\n        const _key = resolveKey(key);\n\n        this.getSemaphoreInstance(_key).release();\n        this.tidy(_key);\n    }\n\n    /**\n     * The number of active locks.  Will always be less or equal to `max`.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    count(key: Key = defaultKey): number {\n        const _key = resolveKey(key);\n\n        return (this.hasSemaphoreInstance(_key))\n            ? this.getSemaphoreInstance(_key).count\n            : 0;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} True if the semaphore and key has locks, false otherwise.\n     */\n    hasTasks(key: Key = defaultKey): boolean {\n        return this.count(key) > 0;\n    }\n\n    /**\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async request<T>(\n        fn: Function,\n        key: KeyOptions = defaultKey,\n    ): Promise<T> {\n        try {\n            await this.acquire(key);\n            return await fn();\n        } finally {\n            this.release(key);\n        }\n    }\n\n    /**\n     * Asynchronously executes `fn` if a lock can be immediately acquired.\n     * Otherwise, returns null.\n     *\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async requestIfAvailable<T>(\n        fn: Function,\n        key: KeyOptions = defaultKey,\n    ): Promise<T | null> {\n        if (this.canAcquire(key)) {\n            return this.request(fn, key);\n        } else {\n            return null;\n        }\n    }\n}\n\nexport { Semaphore };\n","import { Semaphore } from \"./semaphore\";\n\n/**\n * GroupSemaphore manages a shared semaphore for different groups of tasks. Each\n * group is identified by a unique key, and the semaphore ensures only one group\n * can run its tasks concurrently.\n *\n * - acquire(key): Increments the active count for the given group. If it's the\n *   first task for the group (active count is 0), it acquires the global\n *   semaphore, ensuring only one group's tasks can proceed at a time.\n *   Subsequent calls in the group increment the count and are permitted to run.\n * - release(key): Decrements the active count for the group. If the last task\n *   for that group is released, it releases the global semaphore, allowing\n *   other groups to proceed.\n *\n * This ensures that only one group can execute concurrently, but multiple tasks\n * within the same group can run as long as no other tasks from different groups\n * are active.\n */\nclass GroupSemaphore {\n    private _semaphore = new Semaphore();\n    private _activeCounts: Record<string, number> = {};\n    private _groupWaiters: Record<string, Promise<void>> = {};\n\n    async acquire(key: string) {\n        const activeCount = this._activeCounts[key] ?? 0;\n        this._activeCounts[key] = activeCount + 1;\n        const waiter = this._groupWaiters[key] ?? this._semaphore.acquire();\n        this._groupWaiters[key] = waiter;\n        await waiter;\n    }\n\n    release(key: string) {\n        const activeCount = this._activeCounts[key];\n\n        if (activeCount === 1) {\n            this._semaphore.release();\n            delete this._activeCounts[key];\n            delete this._groupWaiters[key];\n        } else {\n            this._activeCounts[key] = activeCount - 1;\n        }\n    }\n}\n\nexport { GroupSemaphore };\n"],"names":["defaultKey","_isPrimitiveKey","item","includes","resolveKey","_ref","key","SemaphoreItem","maxConcurrent","queue","count","this","_proto","prototype","incrementCount","decrementCount","acquire","priority","_this","canAcquire","Promise","resolve","push","sort","a","b","release","resolveFunc","shift","setTimeout","get","Semaphore","semaphoreInstances","_proto2","hasSemaphoreInstance","Boolean","getSemaphoreInstance","tidy","_key","_ref2","_priority","hasTasks","request","fn","_this2","then","_finallyRethrows","_wasThrown","_result","e","reject","requestIfAvailable","GroupSemaphore","_semaphore","_activeCounts","_groupWaiters","_this$_activeCounts$k","_this$_groupWaiters$k","activeCount","waiter"],"mappings":"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"}