{"version":3,"sources":["../src/semaphore.ts","../src/group-semaphore.ts"],"sourcesContent":["const defaultKey = \"_default\";\n\ntype KeyPrimitive = string | number;\n\ntype Key = KeyPrimitive | { key?: KeyPrimitive };\ntype KeyOptions = Key & { priority?: number };\n\nconst _isPrimitiveKey = (item: Key): item is KeyPrimitive =>\n    [\"string\", \"number\"].includes(typeof item);\n\nconst resolveKey = (item: Key): KeyPrimitive =>\n    (_isPrimitiveKey(item) ? item : item.key) ?? defaultKey;\n\nconst resolvePriority = (item: KeyOptions) =>\n    (_isPrimitiveKey(item) ? 0 : item.priority) ?? 0;\n\nclass SemaphoreItem {\n    private queue: Array<{\n        resolve: Function;\n        priority: number;\n    }>;\n    private maxConcurrent: number;\n\n    /**\n     * The number of locks.\n     */\n    public count: number;\n\n    constructor(maxConcurrent: number) {\n        this.queue = [];\n        this.maxConcurrent = maxConcurrent;\n        this.count = 0;\n    }\n\n    get canAcquire(): boolean {\n        return this.count < this.maxConcurrent;\n    }\n\n    private incrementCount() {\n        this.count++;\n    }\n\n    private decrementCount() {\n        this.count--;\n    }\n\n    acquire(priority: number): Promise<void> {\n        if (this.canAcquire) {\n            this.incrementCount();\n            return Promise.resolve();\n        } else {\n            return new Promise((resolve) => {\n                this.queue.push({ resolve, priority });\n                this.queue.sort((a, b) => b.priority - a.priority);\n            });\n        }\n    }\n\n    release(): void {\n        const resolveFunc = this.queue.shift();\n\n        if (resolveFunc) {\n            // Give the micro task queue a small break instead of calling resolveFunc() directly\n            setTimeout(resolveFunc.resolve, 0);\n            // queueMicrotask(() => resolveFunc.resolve());\n        } else {\n            this.decrementCount();\n        }\n    }\n}\n\nclass Semaphore {\n    private semaphoreInstances: Record<string | number, SemaphoreItem>;\n    private maxConcurrent: number;\n\n    /**\n     * @param {number} [maxConcurrent] The maximum number of concurrent locks.\n     */\n    constructor(maxConcurrent: number = 1) {\n        this.semaphoreInstances = {};\n        this.maxConcurrent = maxConcurrent;\n\n        if (maxConcurrent < 1) {\n            throw new Error(\"The maxConcurrent must be 1 or greater.\");\n        }\n    }\n\n    private hasSemaphoreInstance(key: KeyPrimitive = defaultKey) {\n        return Boolean(this.semaphoreInstances[key]);\n    }\n\n    private getSemaphoreInstance(key: KeyPrimitive = defaultKey) {\n        if (!this.hasSemaphoreInstance(key)) {\n            this.semaphoreInstances[key] = new SemaphoreItem(\n                this.maxConcurrent,\n            );\n        }\n        return this.semaphoreInstances[key] as SemaphoreItem;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    private tidy(key: KeyPrimitive = defaultKey): void {\n        if (\n            this.hasSemaphoreInstance(key) &&\n            this.getSemaphoreInstance(key).count === 0\n        ) {\n            delete this.semaphoreInstances[key];\n        }\n    }\n\n    /**\n     * A synchronous function to determine whether a lock can be acquired.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} Returns true if the lock on `key` can be acquired, false\n     * otherwise.\n     */\n    canAcquire(key: Key = defaultKey): boolean {\n        const _key = resolveKey(key);\n\n        return !this.hasSemaphoreInstance(_key) ||\n            this.getSemaphoreInstance(_key).canAcquire;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    acquire(key: KeyOptions = defaultKey) {\n        const _key = resolveKey(key);\n        const _priority = resolvePriority(key);\n\n        return this.getSemaphoreInstance(_key).acquire(_priority);\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    release(key: Key = defaultKey): void {\n        const _key = resolveKey(key);\n\n        this.getSemaphoreInstance(_key).release();\n        this.tidy(_key);\n    }\n\n    /**\n     * The number of active locks.  Will always be less or equal to `max`.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    count(key: Key = defaultKey): number {\n        const _key = resolveKey(key);\n\n        return (this.hasSemaphoreInstance(_key))\n            ? this.getSemaphoreInstance(_key).count\n            : 0;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} True if the semaphore and key has locks, false otherwise.\n     */\n    hasTasks(key: Key = defaultKey): boolean {\n        return this.count(key) > 0;\n    }\n\n    /**\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async request<T>(\n        fn: Function,\n        key: KeyOptions = defaultKey,\n    ): Promise<T> {\n        try {\n            await this.acquire(key);\n            return await fn();\n        } finally {\n            this.release(key);\n        }\n    }\n\n    /**\n     * Asynchronously executes `fn` if a lock can be immediately acquired.\n     * Otherwise, returns null.\n     *\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async requestIfAvailable<T>(\n        fn: Function,\n        key: KeyOptions = defaultKey,\n    ): Promise<T | null> {\n        if (this.canAcquire(key)) {\n            return this.request(fn, key);\n        } else {\n            return null;\n        }\n    }\n}\n\nexport { Semaphore };\n","import { Semaphore } from \"./semaphore\";\n\n/**\n * GroupSemaphore manages a shared semaphore for different groups of tasks. Each\n * group is identified by a unique key, and the semaphore ensures only one group\n * can run its tasks concurrently.\n *\n * - acquire(key): Increments the active count for the given group. If it's the\n *   first task for the group (active count is 0), it acquires the global\n *   semaphore, ensuring only one group's tasks can proceed at a time.\n *   Subsequent calls in the group increment the count and are permitted to run.\n * - release(key): Decrements the active count for the group. If the last task\n *   for that group is released, it releases the global semaphore, allowing\n *   other groups to proceed.\n *\n * This ensures that only one group can execute concurrently, but multiple tasks\n * within the same group can run as long as no other tasks from different groups\n * are active.\n */\nclass GroupSemaphore {\n    private _semaphore = new Semaphore();\n    private _activeCounts: Record<string, number> = {};\n    private _groupWaiters: Record<string, Promise<void>> = {};\n\n    async acquire(key: string) {\n        const activeCount = this._activeCounts[key] ?? 0;\n        this._activeCounts[key] = activeCount + 1;\n        const waiter = this._groupWaiters[key] ?? this._semaphore.acquire();\n        this._groupWaiters[key] = waiter;\n        await waiter;\n    }\n\n    release(key: string) {\n        const activeCount = this._activeCounts[key] as number;\n\n        if (activeCount === 1) {\n            this._semaphore.release();\n            delete this._activeCounts[key];\n            delete this._groupWaiters[key];\n        } else {\n            this._activeCounts[key] = activeCount - 1;\n        }\n    }\n}\n\nexport { GroupSemaphore };\n"],"mappings":"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","names":[]}