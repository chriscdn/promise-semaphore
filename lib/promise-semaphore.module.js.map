{"version":3,"file":"promise-semaphore.module.js","sources":["../src/semaphore.ts","../src/group-semaphore.ts"],"sourcesContent":["const defaultKey = \"_default\";\n\ntype KeyPrimitive = string | number;\n\ntype Key = KeyPrimitive | { key?: KeyPrimitive };\ntype KeyOptions = Key & { priority?: number };\n\nconst _isPrimitiveKey = (item: Key): item is KeyPrimitive =>\n    [\"string\", \"number\"].includes(typeof item);\n\nconst resolveKey = (item: Key): KeyPrimitive =>\n    (_isPrimitiveKey(item) ? item : item.key) ?? defaultKey;\n\nconst resolvePriority = (item: KeyOptions) =>\n    (_isPrimitiveKey(item) ? 0 : item.priority) ?? 0;\n\nclass SemaphoreItem {\n    private queue: Array<{\n        resolve: Function;\n        priority: number;\n    }>;\n    private maxConcurrent: number;\n\n    /**\n     * The number of locks.\n     */\n    public count: number;\n\n    constructor(maxConcurrent: number) {\n        this.queue = [];\n        this.maxConcurrent = maxConcurrent;\n        this.count = 0;\n    }\n\n    get canAcquire(): boolean {\n        return this.count < this.maxConcurrent;\n    }\n\n    private incrementCount() {\n        this.count++;\n    }\n\n    private decrementCount() {\n        this.count--;\n    }\n\n    acquire(priority: number): Promise<void> {\n        if (this.canAcquire) {\n            this.incrementCount();\n            return Promise.resolve();\n        } else {\n            return new Promise((resolve) => {\n                this.queue.push({ resolve, priority });\n                this.queue.sort((a, b) => b.priority - a.priority);\n            });\n        }\n    }\n\n    release(): void {\n        const resolveFunc = this.queue.shift();\n\n        if (resolveFunc) {\n            // Give the micro task queue a small break instead of calling resolveFunc() directly\n            setTimeout(resolveFunc.resolve, 0);\n        } else {\n            this.decrementCount();\n        }\n    }\n}\n\nclass Semaphore {\n    private semaphoreInstances: Record<string | number, SemaphoreItem>;\n    private maxConcurrent: number;\n\n    /**\n     * @param {number} [maxConcurrent] The maximum number of concurrent locks.\n     */\n    constructor(maxConcurrent: number = 1) {\n        this.semaphoreInstances = {};\n        this.maxConcurrent = maxConcurrent;\n\n        if (maxConcurrent < 1) {\n            throw new Error(\"The maxConcurrent must be 1 or greater.\");\n        }\n    }\n\n    private hasSemaphoreInstance(key: KeyPrimitive = defaultKey) {\n        return Boolean(this.semaphoreInstances[key]);\n    }\n\n    private getSemaphoreInstance(key: KeyPrimitive = defaultKey) {\n        if (!this.hasSemaphoreInstance(key)) {\n            this.semaphoreInstances[key] = new SemaphoreItem(\n                this.maxConcurrent,\n            );\n        }\n        return this.semaphoreInstances[key];\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    private tidy(key: KeyPrimitive = defaultKey): void {\n        if (\n            this.hasSemaphoreInstance(key) &&\n            this.getSemaphoreInstance(key).count === 0\n        ) {\n            delete this.semaphoreInstances[key];\n        }\n    }\n\n    /**\n     * A synchronous function to determine whether a lock can be acquired.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} Returns true if the lock on `key` can be acquired, false\n     * otherwise.\n     */\n    canAcquire(key: Key = defaultKey): boolean {\n        const _key = resolveKey(key);\n\n        return !this.hasSemaphoreInstance(_key) ||\n            this.getSemaphoreInstance(_key).canAcquire;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    acquire(key: KeyOptions = defaultKey) {\n        const _key = resolveKey(key);\n        const _priority = resolvePriority(key);\n\n        return this.getSemaphoreInstance(_key).acquire(_priority);\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    release(key: Key = defaultKey): void {\n        const _key = resolveKey(key);\n\n        this.getSemaphoreInstance(_key).release();\n        this.tidy(_key);\n    }\n\n    /**\n     * The number of active locks.  Will always be less or equal to `max`.\n     *\n     * @param {string | number} [key]- Optional, the semaphore key.\n     */\n    count(key: Key = defaultKey): number {\n        const _key = resolveKey(key);\n\n        return (this.hasSemaphoreInstance(_key))\n            ? this.getSemaphoreInstance(_key).count\n            : 0;\n    }\n\n    /**\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {boolean} True if the semaphore and key has locks, false otherwise.\n     */\n    hasTasks(key: Key = defaultKey): boolean {\n        return this.count(key) > 0;\n    }\n\n    /**\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async request<T>(\n        fn: Function,\n        key: KeyOptions = defaultKey,\n    ): Promise<T> {\n        try {\n            await this.acquire(key);\n            return await fn();\n        } finally {\n            this.release(key);\n        }\n    }\n\n    /**\n     * Asynchronously executes `fn` if a lock can be immediately acquired.\n     * Otherwise, returns null.\n     *\n     * @param {Function<T>} fn The function to execute.\n     * @param {string | number} [key]- Optional, the semaphore key.\n     * @returns {Promise<T>}\n     */\n    async requestIfAvailable<T>(\n        fn: Function,\n        key: KeyOptions = defaultKey,\n    ): Promise<T | null> {\n        if (this.canAcquire(key)) {\n            return this.request(fn, key);\n        } else {\n            return null;\n        }\n    }\n}\n\nexport { Semaphore };\n","import { Semaphore } from \"./semaphore\";\n\n/**\n * GroupSemaphore manages a shared semaphore for different groups of tasks. Each\n * group is identified by a unique key, and the semaphore ensures only one group\n * can run its tasks concurrently.\n *\n * - acquire(key): Increments the active count for the given group. If it's the\n *   first task for the group (active count is 0), it acquires the global\n *   semaphore, ensuring only one group's tasks can proceed at a time.\n *   Subsequent calls in the group increment the count and are permitted to run.\n * - release(key): Decrements the active count for the group. If the last task\n *   for that group is released, it releases the global semaphore, allowing\n *   other groups to proceed.\n *\n * This ensures that only one group can execute concurrently, but multiple tasks\n * within the same group can run as long as no other tasks from different groups\n * are active.\n */\nclass GroupSemaphore {\n    private _semaphore = new Semaphore();\n    private _activeCounts: Record<string, number> = {};\n    private _groupWaiters: Record<string, Promise<void>> = {};\n\n    async acquire(key: string) {\n        const activeCount = this._activeCounts[key] ?? 0;\n        this._activeCounts[key] = activeCount + 1;\n        const waiter = this._groupWaiters[key] ?? this._semaphore.acquire();\n        this._groupWaiters[key] = waiter;\n        await waiter;\n    }\n\n    release(key: string) {\n        const activeCount = this._activeCounts[key];\n\n        if (activeCount === 1) {\n            this._semaphore.release();\n            delete this._activeCounts[key];\n            delete this._groupWaiters[key];\n        } else {\n            this._activeCounts[key] = activeCount - 1;\n        }\n    }\n}\n\nexport { GroupSemaphore };\n"],"names":["defaultKey","_isPrimitiveKey","item","includes","resolveKey","_ref","key","SemaphoreItem","maxConcurrent","queue","this","count","_proto","prototype","_createClass","incrementCount","decrementCount","acquire","priority","_this","canAcquire","Promise","resolve","push","sort","a","b","release","resolveFunc","shift","setTimeout","get","Semaphore","semaphoreInstances","Error","_proto2","hasSemaphoreInstance","Boolean","getSemaphoreInstance","tidy","_key","_ref2","_priority","hasTasks","request","fn","_this2","then","_finallyRethrows","_wasThrown","_result","e","reject","requestIfAvailable","GroupSemaphore","_semaphore","_activeCounts","_groupWaiters","_this$_activeCounts$k","_this$_groupWaiters$k","activeCount","waiter"],"mappings":"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"}